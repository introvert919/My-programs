equal

Описание
Сравнивает два диапазона поэлементно на признак равенства или равноценности в смысле, заданном бинарным предикатом.
Используйте std::equal при сравнении элементов в разных типах контейнеров (например vector , и list) или при сравнении различных типов элементов или при сравнении подрангов контейнеров. При сравнении элементов одного типа в контейнерах одного типа используйте оператор operator==, предоставляемый для каждого контейнера.
Используйте перегрузки двойного диапазона в коде C++14, так как перегрузки, которые принимают только один итератор для второго диапазона, не будут обнаруживать различия, если второй диапазон длиннее первого диапазона. Эти перегрузки будут привести к неопределенному поведению, если второй диапазон короче первого диапазона.

Параметры
exec
Используемая политика выполнения.
first1
Входной итератор, указывающий на положение первого элемента в первом диапазоне для тестирования.
last1
Входной итератор, указывающий на положение, следующее за последним элементом, в первом диапазоне для тестирования.
first2
Входной итератор, указывающий на положение первого элемента во втором диапазоне для тестирования.
last2
Входной итератор, указывающий на положение, следующее за последним элементом, во втором диапазоне для тестирования.
pred
Заданный пользователем объект функции предиката, определяющий условие, которое должно выполняться, чтобы два элемента считались эквивалентными друг другу. Бинарный предикат принимает два аргумента и возвращает true в случае соответствия и false в случае несоответствия.

Возвращаемое значение
true Значение , если диапазоны идентичны или эквивалентны двоичному предикату при сравнении элемента по элементу; falseв противном случае .

Замечания
Диапазон, по которому ведется поиск, должен быть допустимым. Все итераторы должны поддерживать сброс ссылок и должна быть возможность достижения последнего положения, начиная от первого, путем приращения.
Если два диапазона имеют одинаковую длину, то временная сложность алгоритма линейно зависит от числа элементов в диапазоне. В противном случае функция немедленно возвращает значение false.
Вам не нужно operator== либо определяемый пользователем предикат, чтобы навязать отношение эквивалентности, которое симметрично, рефлексивно и транзитивно между операндами.

Пример

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
    vector<int> v1 { 0, 5, 10, 15, 20, 25 };
    vector<int> v2 { 0, 5, 10, 15, 20, 25 };
    vector<int> v3 { 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50 };

    // Using range-and-a-half equal:
    bool b = equal(v1.begin(), v1.end(), v2.begin());
    cout << "v1 and v2 are equal: "
       << b << endl; // true, as expected

    b = equal(v1.begin(), v1.end(), v3.begin());
    cout << "v1 and v3 are equal: "
       << b << endl; // true, surprisingly

    // Using dual-range equal:
    b = equal(v1.begin(), v1.end(), v3.begin(), v3.end());
    cout << "v1 and v3 are equal with dual-range overload: "
       << b << endl; // false

    return 0;
}

Output
v1 and v2 are equal: 1
v1 and v3 are equal: 1
v1 and v3 are equal with dual-range overload: 0

Источник: https://learn.microsoft.com/ru-ru/cpp/standard-library/algorithm-functions?view=msvc-170#equal
